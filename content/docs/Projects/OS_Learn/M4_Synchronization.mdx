---
title: "M4: 同步互斥与死锁"
---

## 概述

当多个执行流 (进程/线程) 并发访问共享资源时, 必须协调它们的执行顺序以保证正确性. 本模块深入探讨从硬件原语到高级同步抽象的完整栈, 以及死锁的检测与处理.

---

## 关键概念速查

| 概念 | 英文 | 定义 | 关联内核源码 |
|------|------|------|--------------|
| 临界区 | Critical Section | 访问共享资源的代码段 | - |
| 原子操作 | Atomic Operation | 不可分割的操作序列 | `arch/x86/include/asm/atomic.h` |
| 自旋锁 | Spinlock | 忽等待的锁 | `kernel/locking/spinlock.c` |
| 信号量 | Semaphore | 计数同步原语 | `kernel/locking/semaphore.c` |
| 互斥体 | Mutex | 二元信号量, 带所有者 | `kernel/locking/mutex.c` |
| futex | Fast Userspace Mutex | 用户态/内核态混合锁 | `kernel/futex/core.c` |
| 条件变量 | Condition Variable | 管程同步原语 | pthread 库 |
| 死锁 | Deadlock | 进程循环等待的状态 | - |
| RCU | Read-Copy-Update | 读多写少的无锁高性能机制 | `kernel/rcu/` |
| lockdep | - | 内核死锁检测工具 | `kernel/locking/lockdep.c` |

---

## 模块知识结构

```mermaid
graph TB
    subgraph "M4: 同步与死锁"
        A[竞争条件] --> B[硬件原语]
        B --> C[自旋锁]
        C --> D[信号量]
        D --> E[Mutex / futex]
        E --> F[管程]
        F --> G[死锁]
        G --> H[高级同步]
    end
    
    subgraph "硬件原语"
        B --> B1[CAS]
        B --> B2[内存屏障]
        B --> B3[LL/SC]
    end
    
    subgraph "高级同步机制"
        H --> H1[RCU]
        H --> H2[Seqlock]
        H --> H3[无锁编程]
    end
```

---



## 1. 并发问题基础

### 1.1 竞争条件 (Race Condition)

当程序执行结果依赖于不可控的执行顺序时, 产生竞争条件.例如, 两个线程同时执行 `counter++`: 

```mermaid
sequenceDiagram
    participant TA as Thread A
    participant Reg as CPU Register
    participant C as Memory (counter=0)
    participant TB as Thread B

    TA->>C: 1. load counter (0)
    TA->>Reg: 2. register += 1 (val=1)
    TB->>C: 3. load counter (0)
    Note over TA, TB: 发生上下文切换
    TB->>Reg: 4. register += 1 (val=1)
    TA->>C: 5. store register (1)
    TB->>C: 6. store register (1)
    Note over C: 最终结果: counter = 1 (预期为 2)
```

### 1.2 临界区问题

**临界区 (Critical Section)**: 访问共享资源的代码段.

临界区问题的解决方案必须满足:

| 条件 | 英文 | 说明 |
|------|------|------|
| 互斥 | Mutual Exclusion | 同一时刻仅一个进程在临界区 |
| 进入保证 | Progress | 临界区空闲时, 仅临界区外的进程参与决定谁进入 |
| 有限等待 | Bounded Waiting | 请求进入后在有限时间内获准 |

### 1.3 进程互斥的软件解法

**尝试 1: 严格轮换法 (Strict Alternation)**

```c
// 共享变量
int turn = 0;  // 谁的回合

// 进程 0
while (true) {
    while (turn != 0);  // 忙等待
    // 临界区
    turn = 1;
    // 剩余区
}

// 进程 1
while (true) {
    while (turn != 1);  // 忙等待
    // 临界区
    turn = 0;
    // 剩余区
}
```

**问题**: 违反 Progress — 进程 0 完成后即使进程 1 不需要进入临界区, 进程 0 也无法再次进入.

**尝试 2: 双标志先检查法**

```c
bool flag[2] = {false, false};

// 进程 i
while (true) {
    while (flag[j]);     // 等待对方出来
    flag[i] = true;       // 表示想进入
    // 临界区
    flag[i] = false;
    // 剩余区
}
```

**问题**: 违反 Mutual Exclusion — 两个进程可能同时通过检查.

### 1.4 Peterson 算法

Peterson 算法通过组合 `flag`(表达意愿)和 `turn`(礼让)正确解决了两进程互斥问题: 

```mermaid
graph TD
    Start([开始]) --> Init["flag[i] = true<br/>(我想进)"]
    Init --> Turn["turn = j<br/>(礼让对手)"]
    
    subgraph WaitLoop ["自旋等待区"]
        direction TB
        Check{"flag[j] && turn == j?"}
        Check -- "Yes" --> Spin["忙等待 (Spin)"]
        Spin --> Check
    end
    
    Turn --> Check
    Check -- "No" --> CS["进入临界区 (Critical Section)"]
    
    CS --> Leave["flag[i] = false<br/>(释放锁定)"]
    Leave --> End([结束])
    
    style WaitLoop fill:#fef7e0,stroke:#fbbc04
    style CS fill:#e8f0fe,stroke:#4285f4
```

**Peterson 算法实现 (POSIX C + 内存屏障)**:

在现代多核 CPU 上, 由于**乱序执行 (Out-of-Order Execution)**, 简单的 Peterson 算法会失效. 必须显式加入内存屏障以确保内存可见性顺序:

```c
#include <stdatomic.h>

atomic_bool flag[2] = {false, false};
atomic_int turn;

void enter_critical_section(int i) {
    int j = 1 - i;
    atomic_store_explicit(&flag[i], true, memory_order_relaxed);
    atomic_store_explicit(&turn, j, memory_order_release); // 确保 flag 写入在 turn 之前
    
    // 全局屏障, 强制同步内存视图
    atomic_thread_fence(memory_order_seq_cst); 
    
    while (atomic_load_explicit(&flag[j], memory_order_acquire) && 
           atomic_load_explicit(&turn, memory_order_acquire) == j) {
        // busy wait
    }
}

void leave_critical_section(int i) {
    atomic_store_explicit(&flag[i], false, memory_order_release);
}
```

**正确性证明**:

```
假设两进程都在临界区:
- flag[0] = flag[1] = true
- turn 只能是 0 或 1 (不能同时为两个值)
- 若 turn = 0, 则进程 1 在 while 循环等待
- 若 turn = 1, 则进程 0 在 while 循环等待
矛盾! 故最多一个进程在临界区.
```

**Peterson 算法在现代 CPU 上的问题**:

由于现代 CPU 存在指令重排和缓存一致性问题, Peterson 算法可能失效:

```c
// 编译器或 CPU 可能重排这两条指令
flag[i] = true;   // (1)
turn = j;         // (2)

// 如果 (2) 在 (1) 之前执行, 互斥可能被破坏
```

**修复方法**: 使用内存屏障

```c
void enter_critical_section(int i) {
    int j = 1 - i;
    flag[i] = true;
    __sync_synchronize();  // 内存屏障
    turn = j;
    __sync_synchronize();
    while (flag[j] && turn == j);
}
```

### 1.5 进程互斥与进程同步的概念

| 概念 | 英文 | 定义 | 示例 |
|------|------|------|------|
| 进程互斥 | Mutual Exclusion | 多进程争用同一资源时的排他性访问 | 打印机,共享变量 |
| 进程同步 | Synchronization | 多进程在执行顺序上的协调 | 生产者-消费者 |

```mermaid
graph TD
    subgraph Mutex ["互斥 (Mutex): 互不打扰"]
        A1[进程 A: CS] -. "抢占失败" .-> B1[进程 B: 等待]
    end

    subgraph Sync ["同步 (Sync): 有序协作"]
        A2[生产者: 做完] -- signal --> B2[消费者: 开始]
    end
```

### 1.6 睡眠与唤醒机制

忙等待 (Busy Waiting / Spin) 浪费 CPU, 睡眠-唤醒机制更高效:

```c
// 生产者-消费者 (错误版本, 有 lost wakeup 问题)
#define N 100
int count = 0;

void producer() {
    while (true) {
        item = produce();
        if (count == N)
            sleep();       // 缓冲区满, 睡眠等待
        insert(item);
        count++;
        if (count == 1)
            wakeup(consumer);  // 唤醒消费者
    }
}

void consumer() {
    while (true) {
        if (count == 0)
            sleep();       // 缓冲区空, 睡眠等待
        item = remove();
        count--;
        if (count == N - 1)
            wakeup(producer);  // 唤醒生产者
        consume(item);
    }
}
```

**Lost Wakeup 问题**:

```
1. count = 0
2. 消费者检查 count == 0, 准备睡眠
3. 调度器切换到生产者
4. 生产者生产一项, count = 1
5. 生产者调用 wakeup(consumer), 但消费者还没睡
6. wakeup 信号丢失!
7. 消费者睡眠
8. 生产者继续生产直到满, 然后睡眠
9. 两者都在睡眠 → 死锁
```

**解决方案**: 使用信号量 (Semaphore)

---

## 2. 硬件同步原语

### 2.1 原子指令

| 指令 | 英文 | 架构 | 语义 |
|------|------|------|------|
| TSL/XCHG | Test and Set Lock | x86 | 原子交换 |
| CAS | Compare and Swap | x86 (`CMPXCHG`) | 原子比较并交换 |
| LL/SC | Load-Linked/Store-Conditional | ARM, MIPS, RISC-V | 链接加载/条件存储 |
| FAA | Fetch and Add | x86 (`LOCK XADD`) | 原子加法 |

### 2.2 x86 CAS 实现

```c
// CAS 语义
bool CAS(int *addr, int expected, int new_val) {
    if (*addr == expected) {
        *addr = new_val;
        return true;
    }
    return false;
}

// x86 内联汇编
static inline bool cas(volatile int *addr, int expected, int new_val) {
    char result;
    __asm__ __volatile__ (
        "lock cmpxchgl %3, %1\n\t"
        "sete %0"
        : "=q"(result), "+m"(*addr), "+a"(expected)
        : "r"(new_val)
        : "memory", "cc"
    );
    return result;
}
```

### 2.3 内存屏障 (Memory Barrier)

现代 CPU 可能重排指令或缓存写入, 需要内存屏障保证顺序:

| 类型 | x86 指令 | 作用 |
|------|----------|------|
| 编译器屏障 | `asm volatile(" ::: "memory")` | 阻止编译器重排 |
| Store Fence | `SFENCE` | 保证之前的 store 完成 |
| Load Fence | `LFENCE` | 保证之前的 load 完成 |
| Full Fence | `MFENCE` | 保证所有内存操作完成 |

```c
// Linux 内核中的屏障
smp_mb();    // 全屏障
smp_rmb();   // 读屏障
smp_wmb();   // 写屏障
```

### 2.4 缓存一致性影响

CAS 等原子操作需要跨 CPU 缓存同步:

```
CPU 0 执行 LOCK CMPXCHG:
1. 获取缓存行独占权 (MESI Exclusive/Modified)
2. 锁定总线或使用缓存锁定协议
3. 执行 CAS 操作
4. 释放锁定

其他 CPU 对该缓存行的访问被阻塞 → 性能开销
```

---

## 3. 自旋锁 (Spinlock)

### 3.1 基本自旋锁

```c
typedef struct {
    volatile int locked;
} spinlock_t;

void spin_lock(spinlock_t *lock) {
    while (__sync_lock_test_and_set(&lock->locked, 1)) {
        // 忙等待 (自旋)
        while (lock->locked) {
            __builtin_ia32_pause();  // CPU hint: 减少功耗
        }
    }
}

void spin_unlock(spinlock_t *lock) {
    __sync_lock_release(&lock->locked);
}
```

### 3.2 Ticket Lock

解决基本自旋锁的公平性问题:

```c
typedef struct {
    volatile unsigned int next;   // 下一个票号
    volatile unsigned int owner;  // 当前服务的票号
} ticket_lock_t;

void ticket_lock(ticket_lock_t *lock) {
    unsigned int my_ticket = __sync_fetch_and_add(&lock->next, 1);
    while (lock->owner != my_ticket) {
        __builtin_ia32_pause();
    }
}

void ticket_unlock(ticket_lock_t *lock) {
    lock->owner++;
}
```

### 3.3 Linux 内核自旋锁

```c
// include/linux/spinlock_types.h
typedef struct raw_spinlock {
    arch_spinlock_t raw_lock;
} raw_spinlock_t;

// 使用
spinlock_t lock;
spin_lock_init(&lock);

spin_lock(&lock);
// 临界区
spin_unlock(&lock);

// 关闭本地中断的版本 (防止死锁)
spin_lock_irqsave(&lock, flags);
// 临界区
spin_unlock_irqrestore(&lock, flags);
```

**不同变体**:

| API | 作用 |
|-----|------|
| `spin_lock()` | 获取锁 |
| `spin_lock_irq()` | 获取锁并关闭本地中断 |
| `spin_lock_irqsave()` | 获取锁并保存/关闭中断状态 |
| `spin_lock_bh()` | 获取锁并关闭下半部 |

---

## 4. 信号量 (Semaphore)

### 4.1 Dijkstra 信号量

```c
typedef struct {
    int value;                    // 资源计数
    struct list_head wait_list;   // 等待队列
    spinlock_t lock;              // 保护信号量本身
} semaphore_t;

void P(semaphore_t *sem) {        // Wait / Down
    spin_lock(&sem->lock);
    sem->value--;
    if (sem->value < 0) {
        // 加入等待队列并睡眠
        add_to_wait_list(&sem->wait_list, current);
        spin_unlock(&sem->lock);
        schedule();               // 让出 CPU
    } else {
        spin_unlock(&sem->lock);
    }
}

void V(semaphore_t *sem) {        // Signal / Up
    spin_lock(&sem->lock);
    sem->value++;
    if (sem->value <= 0) {
        // 唤醒一个等待者
        struct task_struct *p = remove_from_wait_list(&sem->wait_list);
        wake_up_process(p);
    }
    spin_unlock(&sem->lock);
}
```

### 4.2 信号量的深度解析: 它能干什么?

信号量不仅仅是一个 "计数器", 它是构造所有高级同步原语的基石. 根据初始值的不同, 信号量有三类核心用法:

| 用法 | 初始值 | 机制 | 示例 |
|------|--------|------|------|
| **互斥锁 (Mutex)** | 1 | P 操作获取锁, V 操作释放锁. 保证同一时间仅一个执行流进入. | 保护全局变量 `balance++` |
| **同步/前驱关系 (Sync)** | 0 | 线程 A 执行完后调用 V, 线程 B 调用 P 等待. 保证 A 先于 B 执行. | 编译过程: 先编译后链接 |
| **资源计数 (Counting)** | N | N 代表可用资源总数. P 申请资源 (N--), V 释放资源 (N++). N=0 时阻塞. | 数据库连接池,缓冲池 |

**代码实例: 生产者-消费者问题**

```mermaid
sequenceDiagram
    participant P as 生产者
    participant S as 信号量 (empty, full, mutex)
    participant B as 缓冲区
    participant C as 消费者

    Note over P: 1. P(empty)
    P->>S: empty-- (等待空车位)
    Note over P: 2. P(mutex)
    P->>S: mutex-- (拿锁)
    P->>B: 3. add_item()
    Note over P: 4. V(mutex)
    P->>S: mutex++ (还锁)
    Note over P: 5. V(full)
    P->>S: full++ (通知消费者)
```

```c
semaphore empty = N;    // 缓冲区空槽位
semaphore full = 0;     // 缓冲区已填充槽位
semaphore mutex = 1;    // 互斥访问缓冲区
// ... 代码实现 ...
```

### 4.3 经典同步问题

#### 4.2.1 生产者-消费者 (Bounded Buffer)

```c
#define N 100
semaphore_t mutex = {1};      // 互斥访问缓冲区
semaphore_t empty = {N};      // 空槽位
semaphore_t full = {0};       // 满槽位

void producer() {
    while (true) {
        item = produce();
        P(&empty);            // 等待空槽
        P(&mutex);            // 进入临界区
        insert(item);
        V(&mutex);            // 离开临界区
        V(&full);             // 增加满槽
    }
}

void consumer() {
    while (true) {
        P(&full);             // 等待满槽
        P(&mutex);            // 进入临界区
        item = remove();
        V(&mutex);            // 离开临界区
        V(&empty);            // 增加空槽
        consume(item);
    }
}
```

#### 4.2.2 读者-写者问题

**读者优先**:

```c
semaphore_t mutex = {1};       // 保护 read_count
semaphore_t wrt = {1};         // 写互斥
int read_count = 0;

void reader() {
    P(&mutex);
    read_count++;
    if (read_count == 1)       // 第一个读者
        P(&wrt);               // 阻止写者
    V(&mutex);
    
    // 读操作
    
    P(&mutex);
    read_count--;
    if (read_count == 0)       // 最后一个读者
        V(&wrt);               // 允许写者
    V(&mutex);
}

void writer() {
    P(&wrt);
    // 写操作
    V(&wrt);
}
```

**问题**: 写者可能饥饿.

---

## 5. 互斥体 (Mutex) 与 futex

### 5.1 用户态 Mutex

```c
typedef struct {
    int locked;                   // 0=未锁定, 1=已锁定
    int contended;                // 是否有竞争
} mutex_t;

void mutex_lock(mutex_t *m) {
    // 快速路径: 尝试 CAS 获取锁
    if (CAS(&m->locked, 0, 1))
        return;  // 成功
    
    // 慢速路径: 进入内核等待
    m->contended = 1;
    while (!CAS(&m->locked, 0, 1)) {
        futex_wait(&m->locked, 1);  // 调用内核
    }
}

void mutex_unlock(mutex_t *m) {
    m->locked = 0;
    if (m->contended) {
        m->contended = 0;
        futex_wake(&m->locked, 1);  // 唤醒一个等待者
    }
}
```

### 5.2 futex 机制

### 5.2 futex 机制

```mermaid
graph TD
    subgraph UserSpace ["用户空间 (User Space)"]
        Fast[快速路径: CAS 原子操作]
        Slow[慢速路径: 系统调用]
    end

    subgraph KernelSpace ["内核空间 (Kernel Space)"]
        WaitQueue[futex 等待队列]
        Check[检查 *uaddr == val]
    end

    Fast -- "成功 (无竞争)" --> Success[直接进入临界区]
    Fast -- "失败 (有竞争)" --> Slow
    Slow -->|syscall| Check
    Check -- "相等" --> WaitQueue
    Check -- "不等" --> Return[返回用户态重试]
    
    style Success fill:#34a853,color:#fff
```

### 5.3 futex 系统调用

```c
#include <linux/futex.h>
#include <sys/syscall.h>

// 等待
syscall(SYS_futex, uaddr, FUTEX_WAIT, val, timeout, NULL, 0);
// 如果 *uaddr == val, 则睡眠

// 唤醒
syscall(SYS_futex, uaddr, FUTEX_WAKE, n, NULL, NULL, 0);
// 唤醒最多 n 个等待者
```

---

## 6. 管程 (Monitor)

### 6.1 管程结构

```mermaid
graph TB
    subgraph Monitor ["管程 (Monitor)"]
        subgraph Internal ["内部私有数据"]
            Data[共享变量 / 资源状态]
        end
        
        subgraph Procs ["导出过程 (Public Methods)"]
            P1[过程 1]
            P2[过程 2]
            P3[过程 3]
        end

        subgraph Queues ["等待队列"]
            EntryQ[入口等待队列]
            CondX[条件变量 X 队列]
            CondY[条件变量 Y 队列]
        end
        
        EntryQ --> Procs
        Procs --> Data
        Procs -. wait/signal .-> CondX
        Procs -. wait/signal .-> CondY
    end
```

### 6.2 条件变量操作

| 操作 | 语义 |
|------|------|
| `wait(c)` | 释放管程锁, 阻塞在条件变量 c 上, 被唤醒后重新获取锁 |
| `signal(c)` | 唤醒一个在 c 上等待的进程 |
| `broadcast(c)` | 唤醒所有在 c 上等待的进程 |

### 6.3 Hoare vs Mesa 语义

| 语义 | signal 后行为 | 唤醒者状态 | 被唤醒者状态 |
|------|---------------|------------|--------------|
| Hoare | 立即切换到被唤醒者 | 阻塞 | 立即运行 |
| Mesa | 唤醒者继续运行 | 继续 | 进入就绪队列 |

**Mesa 语义要求**:

```c
// 必须使用 while, 因为条件可能在被唤醒后变化
while (!condition) {
    pthread_cond_wait(&cond, &mutex);
}
```

### 6.4 Pthread 条件变量

```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int ready = 0;

// 等待者
pthread_mutex_lock(&mutex);
while (!ready) {                                // 循环检查条件
    pthread_cond_wait(&cond, &mutex);           // 原子释放锁并等待
}
// 条件满足, 继续执行
pthread_mutex_unlock(&mutex);

// 通知者
pthread_mutex_lock(&mutex);
ready = 1;
pthread_cond_signal(&cond);                     // 或 pthread_cond_broadcast
pthread_mutex_unlock(&mutex);
```

---

## 7. 优先级反转

### 7.1 问题描述

```
优先级: H > M > L

1. L 获取锁 lock
2. H 尝试获取 lock, 被阻塞
3. M 抢占 L (M 优先级高于 L)
4. H 等待 M 完成后 L 才能释放锁

结果: 高优先级 H 被中优先级 M 间接阻塞
```

### 7.2 解决方案

| 方案 | 英文 | 机制 |
|------|------|------|
| 优先级继承 | Priority Inheritance | 持锁的低优先级进程临时继承等待者的优先级 |
| 优先级天花板 | Priority Ceiling | 锁有固定的天花板优先级, 持锁进程提升到该优先级 |

### 7.3 Linux rt_mutex

```c
// kernel/locking/rtmutex.c
// 实现优先级继承

// 当高优先级任务等待锁时
static int rt_mutex_adjust_prio_chain(...) {
    // 遍历等待链
    // 将锁持有者的优先级提升到等待者中最高的
    task->prio = min(task->prio, waiter->prio);
}
```

---

## 8. 死锁

### 8.1 死锁的四个必要条件

| 条件 | 英文 | 说明 |
|------|------|------|
| 互斥 | Mutual Exclusion | 资源不可共享 |
| 持有并等待 | Hold and Wait | 持有资源同时等待其他资源 |
| 非抢占 | No Preemption | 资源只能由持有者释放 |
| 循环等待 | Circular Wait | 存在等待环路 |

### 8.2 资源分配图

```mermaid
graph LR
    P1[Process 1] -->|Request| R1[Resource 1]
    R1 -->|Held by| P2[Process 2]
    P2 -->|Request| R2[Resource 2]
    R2 -->|Held by| P1
    
    style P1 fill:#f8d7da,stroke:#dc3545
    style P2 fill:#f8d7da,stroke:#dc3545
```
环路: P1 → R1 → P2 → R2 → P1
存在环路 + 单实例资源 = 死锁

### 8.3 银行家算法 (Banker's Algorithm)

**数据结构**:

```c
int Available[m];           // 可用资源向量
int Max[n][m];              // 最大需求矩阵
int Allocation[n][m];       // 已分配矩阵
int Need[n][m];             // 尚需矩阵 (Need = Max - Allocation)
```

**安全性算法**:

```c
bool is_safe() {
    int Work[m];
    bool Finish[n];
    
    // 初始化
    memcpy(Work, Available, sizeof(Work));
    memset(Finish, false, sizeof(Finish));
    
    int count = 0;
    while (count < n) {
        bool found = false;
        for (int i = 0; i < n; i++) {
            if (!Finish[i] && need_le_work(Need[i], Work)) {
                // 模拟进程 i 完成
                for (int j = 0; j < m; j++)
                    Work[j] += Allocation[i][j];
                Finish[i] = true;
                found = true;
                count++;
            }
        }
        if (!found) break;  // 无法继续
    }
    
    return (count == n);  // 所有进程都能完成则安全
}
```

**示例**:

```
进程   Max     Allocation   Need    Available
      A B C     A B C       A B C    A B C
P0    7 5 3     0 1 0       7 4 3    3 3 2
P1    3 2 2     2 0 0       1 2 2
P2    9 0 2     3 0 2       6 0 0
P3    2 2 2     2 1 1       0 1 1
P4    4 3 3     0 0 2       4 3 1

安全序列: `<P1, P3, P4, P0, P2>` (存在至少一个)
```

---

---

## 9. 锁机制深度对比

操作系统中存在多种锁机制, 不同的锁适用于不同的临界区长度和上下文环境.

| 锁类型 | 机制 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **自旋锁 (Spinlock)** | CPU 忙等待 (Busy-waiting), 不释放 CPU | 无上下文切换开销 | 浪费 CPU 周期; 持锁期间不可睡眠 | 临界区极短 (纳秒/微秒级); 中断上下文 |
| **互斥体 (Mutex)** | 无法获取时进程睡眠, 让出 CPU | 不占用 CPU 周期 | 存在两次上下文切换开销 (睡眠/唤醒) | 临界区较长 (毫秒级); 允许睡眠的上下文 |
| **信号量 (Semaphore)** | 计数器机制, 支持多个执行流同时访问 | 灵活性高, 可实现同步,互斥,限流 | 容易导致死锁 (PV 错位置); 维护成本高 | 资源计数 (如连接池); 跨进程同步 |
| **读写锁 (RW-Lock)** | 区分读者和写者; 读共享, 写互斥 | 提高高并发读场景的吞吐量 | 写者可能由于读者过多而饥饿 | 读远远多于写的场景 |
| **RCU (Read-Copy-Update)** | 读者无锁, 写者复制数据并稍后回收 | 读者零开销; 极高伸缩性 (Scalability) | 写者开销巨大; 逻辑复杂; 无法实时回收 | 核心内核数据结构; 读多写极少 |
| **qspinlock (Queued)** | 基于队列的自旋锁, 每个 CPU 自旋在私有变量上 | 解决传统 Ticket Lock 的 Cache Line 震荡问题 | 实现复杂 | 现代 Linux 内核默认自旋锁实现 |

---

## 10. Linux 内核高级同步

### 9.1 RCU (Read-Copy-Update)

适用于读多写少的场景:

```c
// 读侧 (无锁, 极低开销)
rcu_read_lock();
p = rcu_dereference(global_ptr);
// 使用 p 读取数据
rcu_read_unlock();

// 写侧
new = kmalloc(sizeof(*new), GFP_KERNEL);
*new = /* 新数据 */;
old = global_ptr;
rcu_assign_pointer(global_ptr, new);  // 原子发布新版本
synchronize_rcu();                     // 等待所有读者完成
kfree(old);                            // 安全释放旧版本
```

**Grace Period**:

```
写者发布新版本
     │
     ↓
─────┼──────────────────────────────────────────
     │     ← 正在进行的读操作 →      │
─────┼──────────────────────────────────────────
                                     │
                            Grace Period 结束
                                     │
                                     ↓
                              可以安全释放旧数据
```

### 9.2 顺序锁 (Seqlock)

读者不阻塞写者, 但可能需要重试:

```c
seqlock_t lock;

// 写者 (独占)
write_seqlock(&lock);
// 修改数据
write_sequnlock(&lock);

// 读者 (可能重试)
unsigned int seq;
do {
    seq = read_seqbegin(&lock);
    // 读取数据
} while (read_seqretry(&lock, seq));
```

### 9.3 lockdep: 运行时死锁检测

Linux 内核的运行时死锁检测工具, 通过构建锁依赖图 (DAG) 在死锁发生前预警.

#### 9.3.1 工作原理

#### 9.3.1 工作原理

```mermaid
graph TD
    subgraph LockdepGraph ["lockdep 依赖图 (DAG)"]
        direction LR
        L1[锁 A] -- "Thread 1 持 A 拿 B" --> L2[锁 B]
        L2 -- "Thread 2 持 B 拿 C" --> L3[锁 C]
        
        L3 -. "新操作: 持 C 拿 A" .-> L1
    end
    
    L3 -.-> Warning[触发危险警告: Circular Dependency]
    style Warning fill:#ea4335,color:#fff
```

#### 9.3.2 检测类型

| 检测场景 | 说明 |
|----------|------|
| AB-BA 死锁 | 加锁顺序不一致 |
| 递归加锁 | 非递归锁被同一线程重复获取 |
| 中断安全违规 | 中断上下文使用可睡眠的锁 |
| Softirq 安全违规 | 持有 spinlock 时调用可能睡眠的函数 |
| 硬锁链 | hardirq→softirq→process 上下文加锁冲突 |

#### 9.3.3 启用与使用

```c
// 内核配置
CONFIG_LOCKDEP=y
CONFIG_PROVE_LOCKING=y   // 更严格的检测

// 发生警告时的输出示例:
// ======================================================
// WARNING: possible circular locking dependency detected
// ======================================================
// swapper/0/1 is trying to acquire lock:
// (&rq->lock){-.-.}
// 
// but task is already holding lock:
// (&p->pi_lock){-.-.}
// 
// which lock already depends on the new lock.
```

#### 9.3.4 锁类 (Lock Class)

lockdep 使用**锁类**而非锁实例进行追踪:

```c
// 同一锁类的不同实例
spinlock_t lock1, lock2;  // 同类

// 如果需要区分, 使用 lockdep_set_class
lockdep_set_class(&lock1, &key1);
lockdep_set_class(&lock2, &key2);
```

---

## 10. 无锁编程基础

### 10.1 原子变量

```c
#include <stdatomic.h>

atomic_int counter = ATOMIC_VAR_INIT(0);

atomic_fetch_add(&counter, 1);  // 原子加
atomic_load(&counter);          // 原子读
atomic_store(&counter, 0);      // 原子写
```

### 10.2 无锁栈示例

```c
struct node {
    void *data;
    struct node *next;
};

struct lockfree_stack {
    _Atomic(struct node *) head;
};

void push(struct lockfree_stack *s, void *data) {
    struct node *new_node = malloc(sizeof(*new_node));
    new_node->data = data;
    
    struct node *old_head;
    do {
        old_head = atomic_load(&s->head);
        new_node->next = old_head;
    } while (!atomic_compare_exchange_weak(&s->head, &old_head, new_node));
}

void *pop(struct lockfree_stack *s) {
    struct node *old_head;
    do {
        old_head = atomic_load(&s->head);
        if (old_head == NULL) return NULL;
    } while (!atomic_compare_exchange_weak(&s->head, &old_head, old_head->next));
    
    void *data = old_head->data;
    free(old_head);
    return data;
}
```

---

## 11. 锁机制深度对比

### 11.1 内核锁类型全览

| 锁类型 | 机制 | 可睡眠 | 适用场景 | 优点 | 缺点 |
|--------|------|--------|----------|------|------|
| **Spinlock** | 忙等待 (自旋) | 否 | 短临界区, 中断上下文 | 无上下文切换开销 | 浪费 CPU, 不可长持有 |
| **Mutex** | 睡眠等待 | 是 | 长临界区, 进程上下文 | 释放 CPU | 上下文切换开销 |
| **Semaphore** | 计数器 + 睡眠 | 是 | 资源池管理, 信号传递 | 支持多并发, 可跨进程 | 复杂度高 |
| **RWLock** | 读写分离 | 是 | 读多写少场景 | 读并发高 | 写饥饿风险 |
| **RCU** | 延迟销毁 | 读: 否 | 读极多写极少 | 读零开销 | 写复杂, 内存占用 |
| **Seqlock** | 序列号检测 | 读: 否 | 写优先场景 | 写不阻塞 | 读可能重试 |

### 11.2 Spinlock 公平性演进

#### 11.2.1 基础 Spinlock (不公平)

```c
// 测试并设置 (TAS)
void spin_lock(spinlock_t *lock) {
    while (test_and_set(&lock->locked))
        ;  // 自旋
}
```

**问题**: 后来者可能抢先获取锁, 导致**饥饿**.

#### 11.2.2 Ticket Lock (公平但有缓存问题)

```c
struct ticket_lock {
    atomic_t next_ticket;  // 下一个可取号码
    atomic_t now_serving;  // 当前服务号码
};

void spin_lock(struct ticket_lock *lock) {
    int my_ticket = atomic_fetch_add(&lock->next_ticket, 1);
    while (atomic_load(&lock->now_serving) != my_ticket)
        cpu_relax();  // 自旋
}
```

**问题**: 所有 CPU 自旋在同一变量 `now_serving`, 导致**缓存行震荡 (Cache Line Bouncing)**.

#### 11.2.3 MCS Lock (解决缓存震荡)

MCS Lock 通过构建进程链表, 让每个 CPU 仅在本地变量上自旋, 避免了全局变量的缓存一致性开销: 

```mermaid
graph TD
    H[Lock Header] --> CPU0[CPU 0: 持有]
    CPU0 -- next --> CPU1[CPU 1: 自旋于 node1.wait]
    CPU1 -- next --> CPU2[CPU 2: 自旋于 node2.wait]
    CPU2 -- next --> CPU3[CPU 3]
    
    style CPU0 fill:#34a853,color:#fff
    style CPU1 fill:#ea4335,color:#fff
    style CPU2 fill:#ea4335,color:#fff
```

**释放逻辑**: 当 CPU 0 释放时, 直接修改 CPU 1 的本地标志位 `node1.wait = false`, 仅导致 CPU 1 的缓存失效.

#### 11.2.4 Linux qspinlock

Linux 4.2+ 采用 **qspinlock**, 结合了 Ticket Lock 和 MCS:

| 竞争程度 | 行为 |
|----------|------|
| 无竞争 | 原子操作立即获取 |
| 轻度竞争 | 嵌入式自旋 (pending bit) |
| 重度竞争 | 退化为 MCS 队列 |

---

## 12. 信号量深度详解

### 12.1 信号量本质

**信号量 (Semaphore)** 是一个整型变量, 支持两个原子操作:

| 操作 | 荷兰语 | 英文 | 行为 |
|------|--------|------|------|
| P | Proberen (尝试) | wait / down | `S--`; 若 `S < 0` 则阻塞 |
| V | Verhogen (增加) | signal / up | `S++`; 若有等待者则唤醒 |

### 12.2 信号量类型

| 类型 | 初始值 | 用途 |
|------|--------|------|
| **二值信号量** | 1 | 互斥锁替代品 |
| **计数信号量** | N | 资源池管理 (如连接池) |
| **同步信号量** | 0 | 线程间同步/通知 |

### 12.3 信号量三要素

```mermaid
graph TB
    subgraph SemUses ["信号量三大核心用途"]
        direction LR
        Mutex[1. 互斥<br/>sem=1<br/>保护临界区]
        Sync[2. 同步<br/>sem=0<br/>A先B后]
        Count[3. 计数<br/>sem=N<br/>资源池控制]
    end
```

### 12.4 信号量 vs Mutex

| 对比项 | 信号量 | Mutex |
|--------|--------|-------|
| 所有权 | 无 (任何线程可 V) | 有 (必须由持有者释放) |
| 计数 | 支持 | 仅二值 |
| 优先级继承 | 不支持 | 支持 (Linux) |
| 适用场景 | 生产者-消费者, 资源池 | 临界区保护 |

---

## 13. 死锁

### 13.1 死锁概念

**死锁 (Deadlock)**: 一组进程中每个进程都在等待只能由该组其他进程引发的事件, 导致所有进程永久阻塞.

```mermaid
graph TD
    PA[进程 A] -- "请求 (Wait)" --> RY[资源 Y]
    RY -- "持有 (Hold)" --> PB[进程 B]
    PB -- "请求 (Wait)" --> RX[资源 X]
    RX -- "持有 (Hold)" --> PA
    
    style RX fill:#fbbc04
    style RY fill:#fbbc04
```

### 13.2 死锁发生的四个必要条件 (Coffman 条件)

| 条件 | 英文 | 说明 |
|------|------|------|
| **互斥** | Mutual Exclusion | 资源不可共享, 一次只能一个进程使用 |
| **持有并等待** | Hold and Wait | 进程持有资源的同时等待其他资源 |
| **不可抢占** | No Preemption | 资源只能由持有者主动释放 |
| **循环等待** | Circular Wait | 存在进程的循环等待链 |

**关键**: 四个条件必须**同时满足**才会死锁.

### 13.3 死锁处理策略

| 策略 | 英文 | 方法 | 代价 |
|------|------|------|------|
| **预防** | Prevention | 破坏四个条件之一 | 资源利用率低 |
| **避免** | Avoidance | 银行家算法, 动态检查安全态 | 需预知资源需求 |
| **检测+恢复** | Detection + Recovery | 允许死锁发生, 检测后恢复 | 开销大 |
| **忽略** | Ignore (Ostrich) | 假装不会发生 | Unix/Linux 常用 |

### 13.4 银行家算法

银行家算法通过判断系统是否处于**安全状态**来避免死锁:

```
安全状态: 存在一个进程序列 `<P1, P2, ..., Pn>`, 使得每个 `Pi` 的资源需求
         可以被当前可用资源 + 所有 `Pj` (j < i) 持有的资源满足.

Available = [3,3,2]  // 当前可用

        Max       Allocation    Need
P0    [7,5,3]      [0,1,0]    [7,4,3]
P1    [3,2,2]      [2,0,0]    [1,2,2]  ← 可满足
P2    [9,0,2]      [3,0,2]    [6,0,0]
P3    [2,2,2]      [2,1,1]    [0,1,1]  ← 可满足
P4    [4,3,3]      [0,0,2]    [4,3,1]

安全序列: `<P1, P3, P4, P2, P0>`
```

### 13.5 死锁检测

#### 13.5.1 资源分配图 (Resource Allocation Graph)

系统可以通过构建资源分配图来检测死锁.节点的定义如下: 
- **圆圈**: 进程 (P)
- **矩形**: 资源类型 (R)
- **请求边 (P → R)**: 进程 P 正在请求资源 R
- **分配边 (R → P)**: 资源 R 已分配给进程 P

```mermaid
graph TD
    P1((P1)) -- 请求 --> R1[R1]
    R1 -- 分配 --> P2((P2))
    P2 -- 请求 --> R2[R2]
    R2 -- 分配 --> P1
    
    style R1 fill:#ea4335,color:#fff
    style R2 fill:#ea4335,color:#fff
```

**判别准则**: 
1. 如果图中无环, 则一定没有死锁.
2. 如果图中有环, 且每种资源只有一个实例, 则**一定死锁**.
3. 如果图中有环, 且资源有多个实例, 则**可能死锁**.

#### 13.5.2 Linux lockdep (见 §9.3)

Linux 内核使用 lockdep 在**运行时**检测潜在死锁, 通过构建锁依赖 DAG 发现环.

---

## 参考教材

| 主题 | 推荐阅读 |
|------|----------|
| 临界区与软件方案 | *OSTEP* Ch28, *恐龙书* Ch6 |
| 信号量 | *OSTEP* Ch31, *恐龙书* Ch6.5-6.7 |
| 管程 | *恐龙书* Ch6.7, *Tanenbaum* Ch2.3 |
| 死锁 | *OSTEP* Ch32, *恐龙书* Ch8 |
| Linux 内核同步 | *LKD* Ch9-10 |
| RCU | *ULK* Ch5.7, RCU documentation |

---

## 内核源码引用

| 主题 | 源码路径 | 关键函数/结构 |
|------|----------|---------------|
| 原子操作 | `arch/x86/include/asm/atomic.h` | `atomic_add()`, `atomic_cmpxchg()` |
| 自旋锁 | `kernel/locking/spinlock.c` | `spin_lock()`, `spin_unlock()` |
| 自旋锁类型 | `include/linux/spinlock_types.h` | `spinlock_t`, `raw_spinlock_t` |
| 信号量 | `kernel/locking/semaphore.c` | `down()`, `up()` |
| Mutex | `kernel/locking/mutex.c` | `mutex_lock()`, `mutex_unlock()` |
| futex | `kernel/futex/core.c` | `do_futex()`, `futex_wait()` |
| 读写锁 | `kernel/locking/rwsem.c` | `down_read()`, `down_write()` |
| RT Mutex | `kernel/locking/rtmutex.c` | `rt_mutex_lock()` |
| RCU 核心 | `kernel/rcu/tree.c` | `rcu_read_lock()`, `synchronize_rcu()` |
| Seqlock | `include/linux/seqlock.h` | `read_seqbegin()`, `write_seqlock()` |
| lockdep | `kernel/locking/lockdep.c` | `lock_acquire()`, `lock_release()` |
| 等待队列 | `include/linux/wait.h` | `wait_queue_head_t`, `wake_up()` |

**在线源码浏览**: [Bootlin Elixir](https://elixir.bootlin.com/linux/latest/source)

---

## 11. 哲学家就餐问题

### 11.1 问题描述

```mermaid
graph TD
    subgraph Table ["哲学家就餐圆桌"]
        P0((P0)) --- F0[F0]
        F0 --- P1((P1))
        P1 --- F1[F1]
        F1 --- P2((P2))
        P2 --- F2[F2]
        F2 --- P3((P3))
        P3 --- F3[F3]
        F3 --- P4((P4))
        P4 --- F4[F4]
        F4 --- P0
    end
    
    style F0 fill:#fbbc04
    style F1 fill:#fbbc04
    style F2 fill:#fbbc04
    style F3 fill:#fbbc04
    style F4 fill:#fbbc04
```
**规则**: 哲学家需要拿起左右两把叉子才能进餐.所有人都先拿左手叉子会导致**死锁**.

### 11.2 简单解法 (可能死锁)

```c
semaphore fork[5];  // 初始值均为 1

void philosopher(int i) {
    while (true) {
        think();
        P(&fork[i]);           // 拿起左边的叉子
        P(&fork[(i+1) % 5]);   // 拿起右边的叉子
        eat();
        V(&fork[(i+1) % 5]);   // 放下右边的叉子
        V(&fork[i]);           // 放下左边的叉子
    }
}
```

**死锁场景**: 所有哲学家同时拿起左边的叉子, 然后都在等待右边的叉子.

### 11.3 解决方案

**方案 1: 限制就餐人数**

```c
semaphore fork[5];   // 初始值均为 1
semaphore room = 4;  // 最多 4 人同时就餐

void philosopher(int i) {
    while (true) {
        think();
        P(&room);              // 进入餐厅
        P(&fork[i]);
        P(&fork[(i+1) % 5]);
        eat();
        V(&fork[(i+1) % 5]);
        V(&fork[i]);
        V(&room);              // 离开餐厅
    }
}
```

**方案 2: 奇偶有序**

```c
void philosopher(int i) {
    while (true) {
        think();
        if (i % 2 == 0) {
            P(&fork[i]);           // 偶数哲学家先拿左边
            P(&fork[(i+1) % 5]);
        } else {
            P(&fork[(i+1) % 5]);   // 奇数哲学家先拿右边
            P(&fork[i]);
        }
        eat();
        V(&fork[(i+1) % 5]);
        V(&fork[i]);
    }
}
```

**方案 3: 使用管程**

```c
monitor dining_philosophers {
    enum {THINKING, HUNGRY, EATING} state[5];
    condition self[5];
    
    void pickup(int i) {
        state[i] = HUNGRY;
        test(i);
        if (state[i] != EATING)
            self[i].wait();
    }
    
    void putdown(int i) {
        state[i] = THINKING;
        test((i + 4) % 5);  // 测试左邻居
        test((i + 1) % 5);  // 测试右邻居
    }
    
    void test(int i) {
        if (state[(i+4) % 5] != EATING &&
            state[i] == HUNGRY &&
            state[(i+1) % 5] != EATING) {
            state[i] = EATING;
            self[i].signal();
        }
    }
}
```

### 11.4 各方案对比

| 方案 | 优点 | 缺点 |
|------|------|------|
| 限制人数 | 简单有效 | 降低并发度 |
| 奇偶有序 | 无需额外信号量 | 逻辑不对称 |
| 管程 | 清晰, 不会死锁 | 实现复杂 |

---

## 思考题

1. 为什么 Peterson 算法在现代 CPU 上可能失效? 如何修复?
2. futex 如何避免 "lost wakeup" 问题?
3. Mesa 语义下为什么条件等待必须用 `while` 而非 `if`?
4. 银行家算法在实际系统中为何很少使用?
5. RCU 的 Grace Period 是如何确定结束的?
6. 设计一个避免优先级反转的实时调度场景.
