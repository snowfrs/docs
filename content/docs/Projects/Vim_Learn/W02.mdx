---
title: "W02: 空间感知与状态导航"
description: "深入 Jumplists, Changelists 与 Marks 机制, 掌握内存中的 Buffer 管理与跳转技术."
---

## 1. 核心机制: 跳转列表 (Jumplist)

Vim 会自动记录每一次"大规模"的光标移动 (如 `G`, `/`, `%`, `n`).

### 1.1 跳转栈操作

```vim
Ctrl + o    " 跳回上一个位置 (Older)
Ctrl + i    " 跳向下一个位置 (In/Newer)
:jumps      " 查看跳转历史
```

**何时会创建跳转记录**:
- 行号跳转: `G`, `gg`, `:{number}`
- 搜索: `/`, `?`, `n`, `N`, `*`, `#`
- 段落/括号: `{`, `}`, `%`
- 标记跳转: `'x`, `` `x ``
- 行内搜索不会创建跳转记录

### 1.2 跳转工作流

```
场景: 代码追踪深入三层函数调用

main.go:50    ──gd──→  handler.go:120  ──gd──→  service.go:80  ──gd──→  repo.go:200
                                                                          │
                       ←──Ctrl+o──  ←──Ctrl+o──  ←──Ctrl+o──  ←──Ctrl+o──┘
                                                              (逐层返回)
```

### 1.3 修改记录 (Changelist)

```vim
g;          " 跳转到上一个修改点
g,          " 跳转到下一个修改点
:changes    " 查看修改历史
```

**实战场景**: 离开编辑位置去顶部查阅文档后, 按 `g;` 精准回到刚才修改的位置.

---

## 2. 内存治理: 缓冲区 (Buffers)

### 2.1 Buffer vs Window vs Tab

```
┌─────────────────────────────────────────────────────────┐
│                     Tab Page 1                          │
│  ┌─────────────────────┬─────────────────────┐         │
│  │      Window 1       │      Window 2       │         │
│  │   (显示 Buffer A)   │   (显示 Buffer B)   │         │
│  └─────────────────────┴─────────────────────┘         │
└─────────────────────────────────────────────────────────┘

Buffers (内存中): [A] [B] [C] [D] [E] ...
                  可以有很多, 不必全部显示在窗口中
```

**概念**:
- **Buffer**: 内存中的文件内容
- **Window**: 显示 Buffer 的视口
- **Tab**: 窗口布局的集合

### 2.2 缓冲区操作

```vim
:ls                 " 列出所有缓冲区
:buffers            " 同上
:b {name}           " 切换到包含 name 的缓冲区 (模糊匹配)
:b {number}         " 切换到指定编号的缓冲区
:bn                 " 下一个缓冲区
:bp                 " 上一个缓冲区
:bd                 " 删除当前缓冲区 (关闭文件)
:bd!                " 强制删除 (丢弃修改)
:bw                 " 彻底删除缓冲区
:e {file}           " 打开新文件到缓冲区
```

### 2.3 缓冲区状态

`:ls` 输出解读:

```
  1 %a   "main.go"                  line 50
  2 #    "handler.go"               line 120
  3      "service.go"               line 80
  4 +    "config.go"                line 10
```

| 符号 | 含义 |
|------|------|
| `%` | 当前窗口显示的缓冲区 |
| `#` | 备用缓冲区 (可用 `Ctrl+^` 快速切换) |
| `a` | 活动缓冲区 (在窗口中显示) |
| `h` | 隐藏缓冲区 (未在任何窗口显示) |
| `+` | 已修改未保存 |
| `-` | 只读 |
| `=` | 不可修改 |

### 2.4 备用缓冲区快速切换

```vim
Ctrl + ^    " 在当前和备用缓冲区间切换
:b#         " 同上
```

**经典用法**: 在源文件和测试文件间快速切换.

---

## 3. 标记系统 (Marks)

### 3.1 标记类型

| 标记 | 作用域 | 说明 |
|------|--------|------|
| `a-z` | 文件内 | 局部标记, 仅当前文件有效 |
| `A-Z` | 全局 | 跨文件标记, 跳转会切换文件 |
| `0-9` | 特殊 | Vim 自动维护的退出位置 |

### 3.2 标记操作

```vim
m{a-z}      " 设置局部标记
m{A-Z}      " 设置全局标记
'{mark}     " 跳转到标记所在行首
`{mark}     " 跳转到标记的精确位置
:marks      " 查看所有标记
:delmarks a " 删除标记 a
:delm!      " 删除所有局部标记
```

### 3.3 特殊标记 (自动维护)

```vim
''          " 上次跳转前的位置
``          " 同上, 精确位置
'.          " 上次修改的位置
'^          " 上次插入结束的位置
'[  ']      " 上次修改或复制的文本范围
'<  '>      " 上次可视选择的范围
'0          " 上次退出 Vim 时的位置
```

### 3.4 全局标记工作流

```vim
" 项目入口
mM          " main.go 入口函数标记为 M

" API 定义
mA          " api.go 标记为 A

" 配置文件
mC          " config.go 标记为 C

" 使用
'M          " 从任何地方跳转到 main
'A          " 跳转到 API
'C          " 跳转到配置
```

---

## 4. 行号跳转技巧

### 4.1 绝对行号

```vim
:50         " 跳转到第 50 行
50G         " 同上
50gg        " 同上
```

### 4.2 相对行号

开启相对行号后, 垂直移动更直观:

```vim
" ~/.vimrc or init.lua
set relativenumber
set number

" 使用
5j          " 向下 5 行
10k         " 向上 10 行
d5j         " 删除当前行及下面 5 行
```

### 4.3 百分比跳转

```vim
50%         " 跳转到文件 50% 位置
25%         " 跳转到 25% 位置
```

---

## 5. 状态回溯: 撤销树 (Undo Tree)

Vim 的撤销系统不是线性的列表, 而是一棵**树**. 这意味着即使你撤销后做了修改, 之前的旧状态依然存在.

### 5.1 线性撤销与重做

```vim
u           " 撤销 (Undo)
Ctrl + r    " 重做 (Redo)
U           " 撤销对整行的所有修改 (罕用)
```

### 5.2 时间旅行: 基于时间的跳转

```vim
:earlier 15m " 回到 15 分钟前的状态
:earlier 1h  " 回到 1 小时前
:later 5m    " 前进到 5 分钟后的状态
:earlier 10s " 回到 10 秒前
```

### 5.3 撤销的分支 (Undo Branches)

如果你撤销了 5 步, 然后输入了新内容, 在其他编辑器中那 5 步就永远丢了. 在 Vim 中:

```vim
g-          " 移动到较早的状态 (跨越分支)
g+          " 移动到较晚的状态
```

**原理**: `u` 是在撤销历史中垂直移动, 而 `g-` 是按时间顺序在所有状态间移动.

### 5.4 可视化工具: mbbill/undotree

原生命令较难记忆, 强烈建议安装插件进行可视化管理.

```lua
-- plugins/undotree.lua
return {
    "mbbill/undotree",
    keys = {
        { "<leader>u", "<cmd>UndotreeToggle<CR>", desc = "Toggle UndoTree" },
    },
}
```

启用后, 你可以通过侧边栏直观地看到所有代码演进分支, 毫秒级找回一小时前因手滑丢失的代码片段.

### 5.5 撤销持久化 (Persistent Undo)

默认情况下, 关闭 Vim 后撤销历史会丢失. 开启持久化可以让你在隔天打开文件时依然能 `u` 回去.

```lua
-- init.lua
if vim.fn.has("persistent_undo") == 1 then
    local undo_path = vim.fn.stdpath("data") .. "/undo"
    if vim.fn.isdirectory(undo_path) == 0 then
        vim.fn.mkdir(undo_path, "p")
    end
    vim.opt.undodir = undo_path
    vim.opt.undofile = true
end
```

---

## 6. 本周实战任务

### 6.1 跳转导航

1. 打开一个大型项目
2. 使用 `gd` 追踪函数定义 (需要 LSP)
3. 深入 3-4 层后, 使用 `Ctrl+o` 逐层返回
4. 用 `:jumps` 观察跳转历史

### 6.2 缓冲区管理

1. 打开 5 个以上文件
2. 使用 `:ls` 查看缓冲区
3. 仅用 `:b {片段}` 在文件间切换
4. 练习 `Ctrl+^` 快速切换

### 6.3 标记使用

1. 在 main 函数设置全局标记 `mM`
2. 浏览其他文件
3. 用 `'M` 跳回 main
4. 体验局部标记 `ma` 和 `'a`

---

## 7. 配置建议

```lua
-- init.lua

-- 相对行号 (便于 d5j, 10k 等操作)
vim.opt.relativenumber = true
vim.opt.number = true

-- 保持光标居中
vim.opt.scrolloff = 8

-- 快速缓冲区切换
vim.keymap.set("n", "<S-h>", ":bprevious<CR>", { silent = true })
vim.keymap.set("n", "<S-l>", ":bnext<CR>", { silent = true })
vim.keymap.set("n", "<leader>bd", ":bdelete<CR>", { silent = true })

-- 跳转后居中
vim.keymap.set("n", "<C-d>", "<C-d>zz")
vim.keymap.set("n", "<C-u>", "<C-u>zz")
vim.keymap.set("n", "n", "nzzzv")
vim.keymap.set("n", "N", "Nzzzv")
```

---

## 8. 思考题

1. Jumplist 和 Changelist 有什么区别?
2. 为什么 Buffer 比 Tab 更适合管理多文件?
3. 局部标记和全局标记各适合什么场景?
4. `'x` 和 `` `x `` 跳转有什么区别?
5. 相对行号如何提高效率?

---

> 空间感知是 Vim 高效的核心. 当你能在心中构建文件拓扑时, 导航将变成本能反应.
